type CandidSub = record {
    id : nat;
    chain_id : nat;
    contract_addr : text;
    method_name : text;
    method_abi : text;
    frequency : nat;
    is_random : bool;
};

type CandidTypeChain = record {
    chain_id : nat;
    rpc : text;
    min_balance : nat;
    treasurer : text;
};


type Result = variant { Ok : text; Err : text };
type Error = variant { Ok : null; Err : text };
type GetSubsResult = variant { Ok : vec CandidSub; Err : text };
type GetChainsResponse = variant { Ok : vec CandidTypeChain; Err : text};

service : {
    // Will init controllers
    get_controllers : () -> (vec principal);
    // Change the tx fee that takes when a subscription is renewed or created
    // 
    // @param tx_fee The tx fee in cycles, e.g 100000000000
    //
    // @return Error
    update_tx_fee : (tx_fee: nat) -> (Error);

    // Chains methods
    
    // Add a new supported chain
    //
    // @param chain_id The chain id, e.g 1
    // @param rpc The rpc url, e.g http://localhost:8545
    // @param min_balance The minimum balance to have in the chain to be able to create a subscription, e.g 100000000000
    // @param treasurer The treasurer address, e.g 0000000000000000000000000000000000000000
    //
    // @return Error
    add_chain : (chain_id: nat, rpc: text, min_balance: nat, treasurer: text) -> (Error);
    // Remove a supported chain
    //
    // @param chain_id The chain id, e.g 1
    //
    // @return Error
    remove_chain : (chain_id: nat) -> (Error);
    // Update a supported chain rpc
    //
    // @param chain_id The chain id, e.g 1
    // @param rpc The rpc url, e.g http://localhost:8545
    //
    // @return Error
    update_chain_rpc : (chain_id: nat, rpc: text) -> (Error);
    // Update a supported chain min balance
    //
    // @param chain_id The chain id, e.g 1
    // @param min_balance The minimum balance to have in the chain to be able to create a subscription, e.g 100000000000
    //
    // @return Error
    update_chain_min_balance : (chain_id: nat, min_balance: nat) -> (Error);
    // Get a chain rpc
    //
    // @param chain_id The chain id, e.g 1
    //
    // @return Result
    get_chain_rpc : (chain_id: nat) -> (Result);

    get_chains : () -> (GetChainsResponse);

    // Subscriptions methods

    // Create a new subscription
    //
    // @param chain_id The chain id, e.g 1
    // @param pair_id The pair id from Sybil, e.g sample
    // @param contract_addr The smart contract address, e,g 0000000000000000000000000000000000000000
    // @param method_abi The method abi, e,g [{"inputs": [], "name": "get", "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}], "stateMutability": "view", "type": "function"}]
    // @param frequency The frequency in seconds, e,g 60
    // @param is_random If the subscription is random or not, e,g true
    // @param msg The message to sign, e,g *an example is very long, see README*
    // @param sig The signature, e,g *an example is very long, see README*
    //
    // @return Error
    subscribe : (
        chain_id: nat,
        pair_id: opt text,
        contract_addr: text,
        method_abi: text,
        frequency: nat,
        is_random: bool,
        msg: text,
        sig: text,
    ) -> (Error);
    get_subs : (pub_key : text) -> (GetSubsResult);
    // Refresh subscriptions
    //
    // @param chain_id The chain id, e,g 1
    // @param msg The message to sign, e,g *an example is very long, see README*
    // @param sig The signature, e,g *an example is very long, see README*
    //
    // @return Error
    refresh_subs : (chain_id: nat, msg: text, sig: text) -> (Error);

    // users

    // Add a new user
    //
    // @param msg The message to sign, e,g *an example is very long, see README*
    // @param sig The signature, e,g *an example is very long, see README*
    //
    // @return Result
    add_user : (msg: text, sig: text) -> (Result);
}
